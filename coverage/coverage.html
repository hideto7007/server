
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>common: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">server/common/common.go (100.0%)</option>
				
				<option value="file1">server/controllers/annual_income_management_controllers.go (100.0%)</option>
				
				<option value="file2">server/controllers/price_management_controllers.go (100.0%)</option>
				
				<option value="file3">server/controllers/sing_in_controllers.go (0.0%)</option>
				
				<option value="file4">server/models/annual_income.go (99.2%)</option>
				
				<option value="file5">server/models/sing_in.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// common/common.go
package common

import (
        // "fmt"

        "fmt"
        "strconv"
        "time"

        // "net/http"
        "github.com/gin-gonic/gin"
)

type (
        CommonFetcher interface {
                IntgetPrameter(c *gin.Context, prams ...string) (map[string]int, error)
                TimeToStr(t time.Time) string
                StrToTime(dateStr string) (time.Time, error)
                StrToInt(str string) (int, error)
                IntToStr(str int) string
        }
        commonFetcherImpl struct{}
)

func NewCommonFetcher() CommonFetcher <span class="cov8" title="1">{
        return &amp;commonFetcherImpl{}
}</span>

// クエリーパラメータを整数値でまとめたマップで返す。
//
//
// 引数:
//
//        param1: コンテキスト
//        param2: 任意のクエリーパラメータ
//
// 戻り値:
//
//        戻り値1: nilと数値変換出来なかった際のエラー内容
//        戻り値2: 整数値が格納されたマップとnil

func (cf *commonFetcherImpl) IntgetPrameter(c *gin.Context, prams ...string) (map[string]int, error) <span class="cov8" title="1">{
        paramMap := map[string]int{}
        for _, keyParam := range prams </span><span class="cov8" title="1">{
                stringParam := c.DefaultQuery(keyParam, "0")
                intParam, err := strconv.Atoi(stringParam)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">paramMap[keyParam] = intParam</span>
        }
        <span class="cov8" title="1">return paramMap, nil</span>
}

// 日付を文字列に変換
//
// 引数:
//
//        param1: time.Time型
//
// 戻り値:
//
//        戻り値1: 日付を文字列変換

func (cf *commonFetcherImpl) TimeToStr(t time.Time) string <span class="cov8" title="1">{
        return t.Format("2006-01-02")
}</span>

// 文字列日付を日付に変換
//
// 引数:
//
//        param1: string
//
// 戻り値:
//
//        戻り値1: 文字列を日付に変換

func (cf *commonFetcherImpl) StrToTime(dateStr string) (time.Time, error) <span class="cov8" title="1">{
        parsedTime, err := time.Parse("2006-01-02", dateStr)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println("変換エラー:", err)
                return time.Time{}, err
        }</span>
        <span class="cov8" title="1">return parsedTime, nil</span>
}

// 整数値型に変換
//
// 引数:
//
//        param1: string
//
// 戻り値:
//
//        戻り値1: 文字列を整数値型に変換して返す

func (cf *commonFetcherImpl) StrToInt(str string) (int, error) <span class="cov8" title="1">{
        var replaceInt int
        replaceInt, err := strconv.Atoi(str)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println("変換エラー:", err)
                return replaceInt, err
        }</span>
        <span class="cov8" title="1">return replaceInt, nil</span>
}

// 文字列型に変換
//
// 引数:
//
//        param1: int
//
// 戻り値:
//
//        戻り値1: 整数値を文字列型に変換して返す

func (cf *commonFetcherImpl) IntToStr(num int) string <span class="cov8" title="1">{
        replaceString := strconv.Itoa(num)
        return replaceString
}</span>

// // この関数はテストデータを削除するための独立関数
// func TestDataDelete() error {
//         db, err := sql.Open("postgres", config.DataSourceName)
//         if err != nil {
//                 log.Printf("sql.Open error %s", err)
//         }
//         defer db.Close()

//         // トランザクションを開始
//         tx, err := db.Begin()
//         if err != nil {
//                 fmt.Println(err)
//         }

//         deleteStatement := `
//                 DELETE FROM public.incomeforecast_incomeforecastdata
//                 WHERE update_user = 'user123';
//         `

//         if _, err = tx.Exec(deleteStatement); err != nil {
//                 tx.Rollback()
//                 fmt.Println(err)
//         }

//         err = tx.Commit()
//         if err != nil {
//                 fmt.Println(err)
//                 return err
//         }
//         return nil
// }

// クエリーパラメータを整数値でまとめたマップで返す。
//
//
// 引数:
//
//        param1: コンテキスト
//        param2: 任意のクエリーパラメータ
//
// 戻り値:
//
//        戻り値1: nilと数値変換出来なかった際のエラー内容
//        戻り値2: 整数値が格納されたマップとnil

// func IntgetPrameter(req *http.Request, prams ...string) (map[string]int, error) {
//         paramMap := map[string]int{}
//         for _, keyParam := range prams {
//                 stringParam := req.URL.Query().Get(keyParam)
//                 intParam, err := strconv.Atoi(stringParam)
//                 if err != nil {
//                         return nil, err
//                 }
//                 paramMap[keyParam] = intParam
//         }
//         return paramMap, nil
// }
</pre>
		
		<pre class="file" id="file1" style="display: none">// controllers/annual_income_management_controllers.go
package controllers

import (
        "net/http"
        "server/config"
        "server/models" // モデルのインポート

        "github.com/gin-gonic/gin"
)

type (
        IncomeDataFetcher interface {
                GetIncomeDataInRangeApi(c *gin.Context)
                GetDateRangeApi(c *gin.Context)
                GetYearIncomeAndDeductionApi(c *gin.Context)
                InsertIncomeDataApi(c *gin.Context)
                UpdateIncomeDataApi(c *gin.Context)
                DeleteIncomeDataApi(c *gin.Context)
        }

        apiGetIncomeDataFetcher struct{}
)

func NewIncomeDataFetcher() IncomeDataFetcher <span class="cov8" title="1">{
        return &amp;apiGetIncomeDataFetcher{}
}</span>

// GetIncomeDataInRangeApi は登録された給料及び賞与の金額を指定期間で返すAPI
//
// 引数:
//   - c: Ginコンテキスト
//

func (af *apiGetIncomeDataFetcher) GetIncomeDataInRangeApi(c *gin.Context) <span class="cov8" title="1">{
        // パラメータから日付の始まりと終わりを取得
        startDate := c.Query("start_date")
        endDate := c.Query("end_date")
        userId := c.Query("user_id")

        // データベースから指定範囲のデータを取得
        dbFetcher, _, _ := models.NewPostgreSQLDataFetcher(config.DataSourceName)
        incomeData, err := dbFetcher.GetIncomeDataInRange(startDate, endDate, userId)

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        // JSONレスポンスを返す
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"result": incomeData})</span>
}

// GetDateRangeApi は登録されている最も古い日付と最も新しい日付を取得するAPI
// 引数:
//   - c: Ginコンテキスト
//

func (af *apiGetIncomeDataFetcher) GetDateRangeApi(c *gin.Context) <span class="cov8" title="1">{
        // パラメータからユーザー情報取得
        userId := c.Query("user_id")

        // データベースから指定範囲のデータを取得
        dbFetcher, _, _ := models.NewPostgreSQLDataFetcher(config.DataSourceName)
        paymentDate, err := dbFetcher.GetDateRange(userId)

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        // JSONレスポンスを返す
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"result": paymentDate})</span>
}

// GetYearIncomeAndDeductionApi は各年ごとの収入、差引額、手取を取得するAPI
// 引数:
//   - c: Ginコンテキスト
//

func (af *apiGetIncomeDataFetcher) GetYearIncomeAndDeductionApi(c *gin.Context) <span class="cov8" title="1">{
        // パラメータからユーザー情報取得
        userId := c.Query("user_id")

        // データベースから指定範囲のデータを取得
        dbFetcher, _, _ := models.NewPostgreSQLDataFetcher(config.DataSourceName)
        yearIncomeData, err := dbFetcher.GetYearsIncomeAndDeduction(userId)

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        // JSONレスポンスを返す
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"result": yearIncomeData})</span>
}

// InsertIncomeDataApi は新規登録
// 引数:
//   - c: Ginコンテキスト
//

func (af *apiGetIncomeDataFetcher) InsertIncomeDataApi(c *gin.Context) <span class="cov8" title="1">{
        // JSONデータを受け取るための構造体を定義
        var requestData struct {
                Data []models.InsertIncomeData `json:"data"`
        }

        if err := c.ShouldBindJSON(&amp;requestData); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // 収入データベースへ新しいデータ登録
        <span class="cov8" title="1">dbFetcher, _, _ := models.NewPostgreSQLDataFetcher(config.DataSourceName)
        if err := dbFetcher.InsertIncome(requestData.Data); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "データベースへの挿入中にエラーが発生しました"})
                return
        }</span>

        // JSONレスポンスを返す
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"message": "新規給料情報を登録致しました。"})</span>
}

// UpdateIncomeDataApi は更新
// 引数:
//   - c: Ginコンテキスト
//

func (af *apiGetIncomeDataFetcher) UpdateIncomeDataApi(c *gin.Context) <span class="cov8" title="1">{
        var requestData struct {
                Data []models.UpdateIncomeData `json:"data"`
        }

        if err := c.ShouldBindJSON(&amp;requestData); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // 収入データベースの更新
        <span class="cov8" title="1">dbFetcher, _, _ := models.NewPostgreSQLDataFetcher(config.DataSourceName)
        if err := dbFetcher.UpdateIncome(requestData.Data); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "データベースへの挿入中にエラーが発生しました"})
                return
        }</span>

        // JSONレスポンスを返す
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"message": "給料情報の更新が問題なく成功しました。"})</span>
}

// DeleteIncomeDataApi は削除
// 引数:
//   - c: Ginコンテキスト
//

func (af *apiGetIncomeDataFetcher) DeleteIncomeDataApi(c *gin.Context) <span class="cov8" title="1">{

        incomeForecastId := c.Query("income_forecast_id")

        // 収入データベースの指定されたIDの削除
        dbFetcher, _, _ := models.NewPostgreSQLDataFetcher(config.DataSourceName)
        if err := dbFetcher.DeleteIncome([]models.DeleteIncomeData{{IncomeForecastID: incomeForecastId}}); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "データベースからの削除中にエラーが発生しました"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"message": "給料情報の削除が問題なく成功しました。"})</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// controllers/price_management_controllers.go
package controllers

import (
        "net/http"
        "server/common"

        "github.com/gin-gonic/gin"
)

type (
        PriceManagementFetcher interface {
                PriceCalc(moneyReceived, bouns, fixedCost, loan, private, insurance int) PriceInfo
                GetPriceInfoApi(c *gin.Context)
        }

        PriceInfo struct {
                LeftAmount  int `json:"left_amount"`
                TotalAmount int `json:"total_amount"`
        }

        Response struct {
                PriceInfo PriceInfo `json:"result"`
                Error     string    `json:"error,omitempty"`
        }

        apiPriceManagementFetcher struct{}
)

func NewPriceManagementFetcher() PriceManagementFetcher <span class="cov8" title="1">{
        return &amp;apiPriceManagementFetcher{}
}</span>

// PriceCalc は月の収入、ボーナス、固定費、ローン、プライベートの値を使用して、
// 月と1年の貯金額を計算し、PriceInfo 構造体で結果を返します。
//
// 引数:
//   - moneyReceived: 月の収入
//   - bouns: ボーナス
//   - fixedCost: 固定費
//   - loan: ローン
//   - private: プライベート支出
//
// 戻り値:
//   - PriceInfo: 月と1年の貯金額の結果を表す構造体

func (af *apiPriceManagementFetcher) PriceCalc(moneyReceived, bouns, fixedCost, loan, private, insurance int) PriceInfo <span class="cov8" title="1">{

        var priceinfo PriceInfo
        priceinfo.LeftAmount = moneyReceived - fixedCost - loan - private
        priceinfo.TotalAmount = ((priceinfo.LeftAmount * 12) + bouns) - insurance

        return priceinfo
}</span>

// GetPriceInfoApi は価格情報を取得するエンドポイントハンドラーです。
//
// クライアントから送信されたクエリーパラメータ money_received、bouns、fixed_cost、loan、private を
// 解析し、それらの値を使用して価格計算を行います。正常な場合、計算結果を JSON レスポンスとして
// 返し、HTTPステータスコード 200 (OK) を返します。エラーが発生した場合、エラーメッセージを JSON
// レスポンスとして返し、HTTPステータスコード 400 (Bad Request) を返します。
//
// 引数:
//   - c: Ginコンテキスト
//
// 期待するURL:
//
//        GET /get-price-info?money_received=100&amp;bouns=50&amp;fixed_cost=30&amp;loan=20&amp;private=10
//
// 戻り値:
//
//        JSONレスポンス例（成功時）:
//        {
//          "message": {
//            "PriceInfo": {
//              "left_amount": 70,
//              "total_amount": 110
//            }
//          }
//        }
//
//        JSONレスポンス例（エラー時）:
//        {
//          "message": "Invalid query parameters"
//        }

func (af *apiPriceManagementFetcher) GetPriceInfoApi(c *gin.Context) <span class="cov8" title="1">{

        var common common.CommonFetcher = common.NewCommonFetcher()
        data, err := common.IntgetPrameter(c, "money_received", "bouns", "fixed_cost", "loan", "private", "insurance")

        if err == nil </span><span class="cov8" title="1">{
                var price PriceManagementFetcher = NewPriceManagementFetcher()
                res := price.PriceCalc(data["money_received"], data["bouns"], data["fixed_cost"], data["loan"], data["private"], data["insurance"])

                response := Response{PriceInfo: res}

                c.JSON(http.StatusOK, gin.H{"message": response})
        }</span> else<span class="cov8" title="1"> {
                c.JSON(http.StatusBadRequest, gin.H{"message": err})
        }</span>

}
</pre>
		
		<pre class="file" id="file3" style="display: none">// controllers/sing_in_controllers.go
package controllers

import (
        "fmt"
        "net/http"
        "server/config"
        "server/models" // モデルのインポート

        "github.com/gin-gonic/gin"
)

type (
        SingInDataFetcher interface {
                GetSingInApi(c *gin.Context)
                // GetDateRangeApi(c *gin.Context)
                // GetYearIncomeAndDeductionApi(c *gin.Context)
                // InsertIncomeDataApi(c *gin.Context)
                // UpdateIncomeDataApi(c *gin.Context)
                // DeleteIncomeDataApi(c *gin.Context)
        }

        // JSONデータを受け取るための構造体を定義
        requestSingInData struct {
                Data models.RequestSingInData `json:"data"`
        }

        singInResult struct {
                UserId       int    `json:"user_id"`
                UserName     string `json:"user_name"`
                UserPassword string `json:"user_password"`
        }

        singInResponse struct {
                Result   []singInResult `json:"result"`
                ErrorMsg string         `json:"error,omitempty"`
        }

        apiSingInDataFetcher struct{}
)

func NewSingDataFetcher() SingInDataFetcher <span class="cov0" title="0">{
        return &amp;apiSingInDataFetcher{}
}</span>

// getExistsSingInApi はサインイン情報を返すAPI
//
// 引数:
//   - c: Ginコンテキスト
//

func (af *apiSingInDataFetcher) GetSingInApi(c *gin.Context) <span class="cov0" title="0">{
        var reqData requestSingInData
        // requestデータ取得
        if err := c.ShouldBindJSON(&amp;reqData); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">dbFetcher, _, _ := models.NewSingDataFetcher(config.DataSourceName)
        result, err := dbFetcher.GetSingIn(reqData.Data)
        if err != nil </span><span class="cov0" title="0">{
                response := singInResponse{
                        ErrorMsg: "データベースへの挿入中にエラーが発生しました",
                }
                c.JSON(http.StatusInternalServerError, response)
                return
        }</span>
        <span class="cov0" title="0">fmt.Print(result)

        // 結果の処理
        if len(result) &gt; 0 </span><span class="cov0" title="0">{
                // サインイン成功のレスポンス
                response := singInResponse{
                        Result: []singInResult{
                                {
                                        UserId:       result[0].UserId,
                                        UserName:     result[0].UserName,
                                        UserPassword: result[0].UserPassword,
                                },
                        },
                }
                c.JSON(http.StatusOK, response)
        }</span> else<span class="cov0" title="0"> {
                // サインイン失敗のレスポンス
                response := singInResponse{
                        ErrorMsg: "サインインに失敗しました",
                }
                c.JSON(http.StatusUnauthorized, response)
        }</span>
}

// // GetDateRangeApi は登録されている最も古い日付と最も新しい日付を取得するAPI
// // 引数:
// //   - c: Ginコンテキスト
// //

// func (af *apiSingInDataFetcher) GetDateRangeApi(c *gin.Context) {
//         // パラメータからユーザー情報取得
//         userId := c.Query("user_id")

//         // データベースから指定範囲のデータを取得
//         dbFetcher, _, _ := models.NewPostgreSQLDataFetcher(config.DataSourceName)
//         paymentDate, err := dbFetcher.GetDateRange(userId)

//         if err != nil {
//                 c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
//                 return
//         }

//         // JSONレスポンスを返す
//         c.JSON(http.StatusOK, gin.H{"result": paymentDate})
// }

// // GetYearIncomeAndDeductionApi は各年ごとの収入、差引額、手取を取得するAPI
// // 引数:
// //   - c: Ginコンテキスト
// //

// func (af *apiSingInDataFetcher) GetYearIncomeAndDeductionApi(c *gin.Context) {
//         // パラメータからユーザー情報取得
//         userId := c.Query("user_id")

//         // データベースから指定範囲のデータを取得
//         dbFetcher, _, _ := models.NewPostgreSQLDataFetcher(config.DataSourceName)
//         yearIncomeData, err := dbFetcher.GetYearsIncomeAndDeduction(userId)

//         if err != nil {
//                 c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
//                 return
//         }

//         // JSONレスポンスを返す
//         c.JSON(http.StatusOK, gin.H{"result": yearIncomeData})
// }

// // InsertIncomeDataApi は新規登録
// // 引数:
// //   - c: Ginコンテキスト
// //

// func (af *apiSingInDataFetcher) InsertIncomeDataApi(c *gin.Context) {
//         // JSONデータを受け取るための構造体を定義
//         var requestData struct {
//                 Data []models.InsertIncomeData `json:"data"`
//         }

//         if err := c.ShouldBindJSON(&amp;requestData); err != nil {
//                 c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
//                 return
//         }

//         // 収入データベースへ新しいデータ登録
//         dbFetcher, _, _ := models.NewPostgreSQLDataFetcher(config.DataSourceName)
//         if err := dbFetcher.InsertIncome(requestData.Data); err != nil {
//                 c.JSON(http.StatusInternalServerError, gin.H{"error": "データベースへの挿入中にエラーが発生しました"})
//                 return
//         }

//         // JSONレスポンスを返す
//         c.JSON(http.StatusOK, gin.H{"message": "新規給料情報を登録致しました。"})
// }

// // UpdateIncomeDataApi は更新
// // 引数:
// //   - c: Ginコンテキスト
// //

// func (af *apiSingInDataFetcher) UpdateIncomeDataApi(c *gin.Context) {
//         var requestData struct {
//                 Data []models.UpdateIncomeData `json:"data"`
//         }

//         if err := c.ShouldBindJSON(&amp;requestData); err != nil {
//                 c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
//                 return
//         }

//         // 収入データベースの更新
//         dbFetcher, _, _ := models.NewPostgreSQLDataFetcher(config.DataSourceName)
//         if err := dbFetcher.UpdateIncome(requestData.Data); err != nil {
//                 c.JSON(http.StatusInternalServerError, gin.H{"error": "データベースへの挿入中にエラーが発生しました"})
//                 return
//         }

//         // JSONレスポンスを返す
//         c.JSON(http.StatusOK, gin.H{"message": "給料情報の更新が問題なく成功しました。"})
// }

// // DeleteIncomeDataApi は削除
// // 引数:
// //   - c: Ginコンテキスト
// //

// func (af *apiSingInDataFetcher) DeleteIncomeDataApi(c *gin.Context) {

//         incomeForecastId := c.Query("income_forecast_id")

//         // 収入データベースの指定されたIDの削除
//         dbFetcher, _, _ := models.NewPostgreSQLDataFetcher(config.DataSourceName)
//         if err := dbFetcher.DeleteIncome([]models.DeleteIncomeData{{IncomeForecastID: incomeForecastId}}); err != nil {
//                 c.JSON(http.StatusInternalServerError, gin.H{"error": "データベースからの削除中にエラーが発生しました"})
//                 return
//         }

//         c.JSON(http.StatusOK, gin.H{"message": "給料情報の削除が問題なく成功しました。"})
// }
</pre>
		
		<pre class="file" id="file4" style="display: none">// models/anuual_income.go
package models

import (
        "database/sql"
        "fmt"
        "log"
        "server/DB"
        "server/common"
        "time"

        "github.com/DATA-DOG/go-sqlmock"
        "github.com/google/uuid"
        _ "github.com/lib/pq"
)

type (
        AnuualIncomeFetcher interface {
                GetIncomeDataInRange(StartDate, EndDate, UserId string) ([]IncomeData, error)
                GetDateRange(UserID string) ([]PaymentDate, error)
                GetYearsIncomeAndDeduction(UserID string) ([]YearsIncomeData, error)
                InsertIncome(data []InsertIncomeData) error
                UpdateIncome(data []UpdateIncomeData) error
                DeleteIncome(UserID []DeleteIncomeData) error
        }

        IncomeData struct {
                IncomeForecastID uuid.UUID
                PaymentDate      time.Time
                Age              string
                Industry         string
                TotalAmount      int
                DeductionAmount  int
                TakeHomeAmount   int
                Classification   string
                UserID           int
        }

        PaymentDate struct {
                UserID            int
                StratPaymaentDate string
                EndPaymaentDate   string
        }

        YearsIncomeData struct {
                Years           string
                TotalAmount     int
                DeductionAmount int
                TakeHomeAmount  int
        }

        InsertIncomeData struct {
                PaymentDate     string `json:"payment_date"`
                Age             int    `json:"age"`
                Industry        string `json:"industry"`
                TotalAmount     int    `json:"total_amount"`
                DeductionAmount int    `json:"deduction_amount"`
                TakeHomeAmount  int    `json:"take_home_amount"`
                Classification  string `json:"classification"`
                UserID          int    `json:"user_id"`
        }

        UpdateIncomeData struct {
                IncomeForecastID string `json:"income_forecast_id"`
                PaymentDate      string `json:"payment_date"`
                Age              int    `json:"age"`
                Industry         string `json:"industry"`
                TotalAmount      int    `json:"total_amount"`
                DeductionAmount  int    `json:"deduction_amount"`
                TakeHomeAmount   int    `json:"take_home_amount"`
                UpdateUser       string `json:"update_user"`
                Classification   string `json:"classification"`
        }

        DeleteIncomeData struct {
                IncomeForecastID string `form:"income_forecast_id" binding:"required"`
        }

        PostgreSQLDataFetcher struct{ db *sql.DB }
)

func NewPostgreSQLDataFetcher(dataSourceName string) (*PostgreSQLDataFetcher, sqlmock.Sqlmock, error) <span class="cov8" title="1">{
        fmt.Print("dataSourceName", dataSourceName)
        if dataSourceName == "test" </span><span class="cov8" title="1">{
                db, mock, err := sqlmock.New()
                return &amp;PostgreSQLDataFetcher{db: db}, mock, err
        }</span> else<span class="cov8" title="1"> {
                // test実行時に以下のカバレッジは無視する
                db, err := sql.Open("postgres", dataSourceName)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("sql.Open error %s", err)
                }</span>
                <span class="cov8" title="1">return &amp;PostgreSQLDataFetcher{db: db}, nil, nil</span>
        }
}

// GetIncomeDataInRange はDBに登録された給料及び賞与の金額を指定期間で返す。
//
// 引数:
//   - StratPaymaentDate: 始まりの期間
//   - EndPaymaentDate: 終わりの期間
//
// 戻り値:
//
//        戻り値1: 取得したDBの構造体
//        戻り値2: エラー内容(エラーがない場合はnil)
//

func (pf *PostgreSQLDataFetcher) GetIncomeDataInRange(StartDate, EndDate, UserId string) ([]IncomeData, error) <span class="cov8" title="1">{
        var incomeData []IncomeData

        // startDate と endDate を日付型に変換
        start, err := time.Parse("2006-01-02", StartDate)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">end, err := time.Parse("2006-01-02", EndDate)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // データベースクエリを実行
        <span class="cov8" title="1">rows, err := pf.db.Query(DB.GetIncomeDataInRangeSyntax, start, end, UserId)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov8" title="1">{
                var data IncomeData
                err := rows.Scan(
                        &amp;data.IncomeForecastID,
                        &amp;data.PaymentDate,
                        &amp;data.Age,
                        &amp;data.Industry,
                        &amp;data.TotalAmount,
                        &amp;data.DeductionAmount,
                        &amp;data.TakeHomeAmount,
                        &amp;data.Classification,
                        &amp;data.UserID,
                )

                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">incomeData = append(incomeData, data)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return incomeData, nil</span>
}

// GetDateRange は対象ユーザーの情報で最も古い日付と最も新しい日付を取得して返す。
//
// 引数:
//   - UserId: ユーザーID
//
// 戻り値:
//
//        戻り値1: 取得したDBの構造体
//        戻り値2: エラー内容(エラーがない場合はnil)
//

func (pf *PostgreSQLDataFetcher) GetDateRange(UserId string) ([]PaymentDate, error) <span class="cov8" title="1">{
        var paymentDate []PaymentDate

        // データベースクエリを実行
        // 集計関数で値を取得する際は、必ずカラム名を指定する
        rows, err := pf.db.Query(DB.GetDateRangeSyntax, UserId)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        // ユーザーidと日付は別々の型で受け取り、各変数のポインターに渡す
        // rows.Scanがデータを変数に直接書き込むため
        for rows.Next() </span><span class="cov8" title="1">{
                var (
                        userId            int
                        stratPaymaentDate time.Time
                        endPaymaentDate   time.Time
                )
                err := rows.Scan(
                        &amp;userId,
                        &amp;stratPaymaentDate,
                        &amp;endPaymaentDate,
                )

                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                // stratPaymaentDate および endPaymaentDate を文字列に変換
                <span class="cov8" title="1">var common common.CommonFetcher = common.NewCommonFetcher()
                startDateStr := common.TimeToStr(stratPaymaentDate)
                endDateStr := common.TimeToStr(endPaymaentDate)

                // 変換したデータをPaymentDate構造体にセットする
                replaceData := PaymentDate{
                        UserID:            userId,
                        StratPaymaentDate: startDateStr,
                        EndPaymaentDate:   endDateStr,
                }

                paymentDate = append(paymentDate, replaceData)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return paymentDate, nil</span>
}

// GetYearsIncomeAndDeduction は対象ユーザー情報の各年ごとの収入、差引額、手取を取得して返す。
//
// 引数:
//   - UserId: ユーザーID
//
// 戻り値:
//
//        戻り値1: 取得したDBの構造体
//        戻り値2: エラー内容(エラーがない場合はnil)
//

func (pf *PostgreSQLDataFetcher) GetYearsIncomeAndDeduction(UserId string) ([]YearsIncomeData, error) <span class="cov8" title="1">{
        var yearsIncomeData []YearsIncomeData

        // データベースクエリを実行
        // 集計関数で値を取得する際は、必ずカラム名を指定する
        rows, err := pf.db.Query(DB.GetYearsIncomeAndDeductionSyntax, UserId)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        // ユーザーidと日付は別々の型で受け取り、各変数のポインターに渡す
        // rows.Scanがデータを変数に直接書き込むため
        for rows.Next() </span><span class="cov8" title="1">{
                var data YearsIncomeData
                err := rows.Scan(
                        &amp;data.Years,
                        &amp;data.TotalAmount,
                        &amp;data.DeductionAmount,
                        &amp;data.TakeHomeAmount,
                )

                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">yearsIncomeData = append(yearsIncomeData, data)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return yearsIncomeData, nil</span>
}

// InsertIncome は新規登録
//
// 引数:
//   - UserId: ユーザーID
//
// 戻り値:
//
//        戻り値1: 取得したDBの構造体
//        戻り値2: エラー内容(エラーがない場合はnil)
//

func (pf *PostgreSQLDataFetcher) InsertIncome(data []InsertIncomeData) error <span class="cov8" title="1">{

        var err error
        createdAt := time.Now()

        // トランザクションを開始
        tx, err := pf.db.Begin()
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println(err)
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        // エラーが発生した場合、トランザクションをロールバック
                        tx.Rollback()
                }</span> else<span class="cov8" title="1"> {
                        // エラーが発生しなかった場合、トランザクションをコミット
                        err = tx.Commit()
                }</span>
        }()

        <span class="cov8" title="1">insertStatement := DB.InsertIncomeSyntax

        for _, insertData := range data </span><span class="cov8" title="1">{
                data := InsertIncomeData{
                        PaymentDate:     insertData.PaymentDate,
                        Age:             insertData.Age,
                        Industry:        insertData.Industry,
                        TotalAmount:     insertData.TotalAmount,
                        DeductionAmount: insertData.DeductionAmount,
                        TakeHomeAmount:  insertData.TakeHomeAmount,
                        Classification:  insertData.Classification,
                        UserID:          insertData.UserID,
                }
                uuid := uuid.New().String()
                if _, err = tx.Exec(insertStatement,
                        uuid,
                        data.PaymentDate,
                        data.Age,
                        data.Industry,
                        data.TotalAmount,
                        data.DeductionAmount,
                        data.TakeHomeAmount,
                        createdAt,
                        data.Classification,
                        data.UserID); err != nil </span><span class="cov8" title="1">{
                        tx.Rollback()
                        fmt.Println(err)
                }</span>
        }

        // トランザクションをコミット
        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println(err)
                return err
        }</span>

        <span class="cov8" title="1">defer pf.db.Close()

        return nil</span>
}

// UpdateIncome は更新
//
// 引数:
//   - UserId: ユーザーID
//
// 戻り値:
//
//        戻り値1: 取得したDBの構造体
//        戻り値2: エラー内容(エラーがない場合はnil)
//

func (pf *PostgreSQLDataFetcher) UpdateIncome(data []UpdateIncomeData) error <span class="cov8" title="1">{

        var err error
        createdAt := time.Now()

        // トランザクションを開始
        tx, err := pf.db.Begin()
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println(err)
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        // エラーが発生した場合、トランザクションをロールバック
                        tx.Rollback()
                }</span> else<span class="cov8" title="1"> {
                        // エラーが発生しなかった場合、トランザクションをコミット
                        err = tx.Commit()
                }</span>
        }()

        <span class="cov8" title="1">updateStatement := DB.UpdateIncomeSyntax

        for _, updateData := range data </span><span class="cov8" title="1">{
                data := UpdateIncomeData{
                        IncomeForecastID: updateData.IncomeForecastID,
                        PaymentDate:      updateData.PaymentDate,
                        Age:              updateData.Age,
                        Industry:         updateData.Industry,
                        TotalAmount:      updateData.TotalAmount,
                        DeductionAmount:  updateData.DeductionAmount,
                        TakeHomeAmount:   updateData.TakeHomeAmount,
                        UpdateUser:       updateData.UpdateUser,
                        Classification:   updateData.Classification,
                }
                if _, err = tx.Exec(updateStatement,
                        data.PaymentDate,
                        data.Age,
                        data.Industry,
                        data.TotalAmount,
                        data.DeductionAmount,
                        data.TakeHomeAmount,
                        createdAt,
                        data.UpdateUser,
                        data.Classification,
                        data.IncomeForecastID); err != nil </span><span class="cov8" title="1">{
                        tx.Rollback()
                        fmt.Println(err)
                }</span>
        }

        // トランザクションをコミット
        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println(err)
                return err
        }</span>

        <span class="cov8" title="1">defer pf.db.Close()

        return nil</span>
}

// DeleteIncome は削除
//
// 引数:
//   - UserId: ユーザーID
//
// 戻り値:
//
//        戻り値1: 取得したDBの構造体
//        戻り値2: エラー内容(エラーがない場合はnil)
//

func (pf *PostgreSQLDataFetcher) DeleteIncome(data []DeleteIncomeData) error <span class="cov8" title="1">{

        var err error

        // トランザクションを開始
        tx, err := pf.db.Begin()
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println(err)
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        // エラーが発生した場合、トランザクションをロールバック
                        tx.Rollback()
                }</span> else<span class="cov8" title="1"> {
                        // エラーが発生しなかった場合、トランザクションをコミット
                        err = tx.Commit()
                }</span>
        }()

        <span class="cov8" title="1">deleteStatement := DB.DeleteIncomeSyntax

        for _, deleteData := range data </span><span class="cov8" title="1">{
                if _, err = tx.Exec(deleteStatement, deleteData.IncomeForecastID); err != nil </span><span class="cov8" title="1">{
                        tx.Rollback()
                        fmt.Println(err)
                }</span>
        }

        // トランザクションをコミット
        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println(err)
                return err
        }</span>

        <span class="cov8" title="1">defer pf.db.Close()

        return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// models/singin.go
package models

import (
        "database/sql"
        "log"
        "server/DB"

        "github.com/DATA-DOG/go-sqlmock"
        _ "github.com/lib/pq"
)

type (
        SingInFetcher interface {
                GetSingIn(data RequestSingInData) (SingInData, error)
                // GetDateRange(UserID string) ([]PaymentDate, error)
                // GetYearsIncomeAndDeduction(UserID string) ([]YearsIncomeData, error)
                // InsertIncome(data []InsertIncomeData) error
                // UpdateIncome(data []UpdateIncomeData) error
                // DeleteIncome(UserID []DeleteIncomeData) error
        }

        // IncomeData struct {
        //         IncomeForecastID uuid.UUID
        //         PaymentDate      time.Time
        //         Age              string
        //         Industry         string
        //         TotalAmount      int
        //         DeductionAmount  int
        //         TakeHomeAmount   int
        //         Classification   string
        //         UserID           int
        // }

        // PaymentDate struct {
        //         UserID            int
        //         StratPaymaentDate string
        //         EndPaymaentDate   string
        // }

        // YearsIncomeData struct {
        //         Years           string
        //         TotalAmount     int
        //         DeductionAmount int
        //         TakeHomeAmount  int
        // }

        RequestSingInData struct {
                UserName     string `json:"user_name"`
                UserPassword string `json:"user_password"`
        }

        SingInData struct {
                UserId       int
                UserName     string
                UserPassword string
        }

        // UpdateIncomeData struct {
        //         IncomeForecastID string `json:"income_forecast_id"`
        //         PaymentDate      string `json:"payment_date"`
        //         Age              int    `json:"age"`
        //         Industry         string `json:"industry"`
        //         TotalAmount      int    `json:"total_amount"`
        //         DeductionAmount  int    `json:"deduction_amount"`
        //         TakeHomeAmount   int    `json:"take_home_amount"`
        //         UpdateUser       string `json:"update_user"`
        //         Classification   string `json:"classification"`
        // }

        // DeleteIncomeData struct {
        //         IncomeForecastID string `form:"income_forecast_id" binding:"required"`
        // }

        SingInDataFetcher struct{ db *sql.DB }
)

func NewSingDataFetcher(dataSourceName string) (*SingInDataFetcher, sqlmock.Sqlmock, error) <span class="cov0" title="0">{
        if dataSourceName == "test" </span><span class="cov0" title="0">{
                db, mock, err := sqlmock.New()
                return &amp;SingInDataFetcher{db: db}, mock, err
        }</span> else<span class="cov0" title="0"> {
                // test実行時に以下のカバレッジは無視する
                db, err := sql.Open("postgres", dataSourceName)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("sql.Open error %s", err)
                }</span>
                <span class="cov0" title="0">return &amp;SingInDataFetcher{db: db}, nil, nil</span>
        }
}

// ExistsSingIn の存在チェック
//
// 引数:
//   - data: { user_name: string, user_password: string }
//
// 戻り値:
//
//        戻り値1: 存在チェックをtrue　or falseで返す
//        戻り値2: エラー内容(エラーがない場合はnil)
//

func (pf *SingInDataFetcher) GetSingIn(data RequestSingInData) ([]SingInData, error) <span class="cov0" title="0">{

        var result []SingInData
        var err error

        // データベースクエリを実行
        rows, err := pf.db.Query(DB.GetSingInSyntax, data.UserName, data.UserPassword)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var data SingInData
                err := rows.Scan(
                        &amp;data.UserId,
                        &amp;data.UserName,
                        &amp;data.UserPassword,
                )

                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>

                <span class="cov0" title="0">result = append(result, data)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// // GetDateRange は対象ユーザーの情報で最も古い日付と最も新しい日付を取得して返す。
// //
// // 引数:
// //   - UserId: ユーザーID
// //
// // 戻り値:
// //
// //        戻り値1: 取得したDBの構造体
// //        戻り値2: エラー内容(エラーがない場合はnil)
// //

// func (pf *SingInDataFetcher) GetDateRange(UserId string) ([]PaymentDate, error) {
//         var paymentDate []PaymentDate

//         // データベースクエリを実行
//         // 集計関数で値を取得する際は、必ずカラム名を指定する
//         rows, err := pf.db.Query(DB.GetDateRangeSyntax, UserId)

//         if err != nil {
//                 return nil, err
//         }
//         defer rows.Close()

//         // ユーザーidと日付は別々の型で受け取り、各変数のポインターに渡す
//         // rows.Scanがデータを変数に直接書き込むため
//         for rows.Next() {
//                 var (
//                         userId            int
//                         stratPaymaentDate time.Time
//                         endPaymaentDate   time.Time
//                 )
//                 err := rows.Scan(
//                         &amp;userId,
//                         &amp;stratPaymaentDate,
//                         &amp;endPaymaentDate,
//                 )

//                 if err != nil {
//                         return nil, err
//                 }

//                 // stratPaymaentDate および endPaymaentDate を文字列に変換
//                 var common common.CommonFetcher = common.NewCommonFetcher()
//                 startDateStr := common.TimeToStr(stratPaymaentDate)
//                 endDateStr := common.TimeToStr(endPaymaentDate)

//                 // 変換したデータをPaymentDate構造体にセットする
//                 replaceData := PaymentDate{
//                         UserID:            userId,
//                         StratPaymaentDate: startDateStr,
//                         EndPaymaentDate:   endDateStr,
//                 }

//                 paymentDate = append(paymentDate, replaceData)
//         }

//         if err := rows.Err(); err != nil {
//                 return nil, err
//         }

//         return paymentDate, nil
// }

// // GetYearsIncomeAndDeduction は対象ユーザー情報の各年ごとの収入、差引額、手取を取得して返す。
// //
// // 引数:
// //   - UserId: ユーザーID
// //
// // 戻り値:
// //
// //        戻り値1: 取得したDBの構造体
// //        戻り値2: エラー内容(エラーがない場合はnil)
// //

// func (pf *SingInDataFetcher) GetYearsIncomeAndDeduction(UserId string) ([]YearsIncomeData, error) {
//         var yearsIncomeData []YearsIncomeData

//         // データベースクエリを実行
//         // 集計関数で値を取得する際は、必ずカラム名を指定する
//         rows, err := pf.db.Query(DB.GetYearsIncomeAndDeductionSyntax, UserId)

//         if err != nil {
//                 return nil, err
//         }
//         defer rows.Close()

//         // ユーザーidと日付は別々の型で受け取り、各変数のポインターに渡す
//         // rows.Scanがデータを変数に直接書き込むため
//         for rows.Next() {
//                 var data YearsIncomeData
//                 err := rows.Scan(
//                         &amp;data.Years,
//                         &amp;data.TotalAmount,
//                         &amp;data.DeductionAmount,
//                         &amp;data.TakeHomeAmount,
//                 )

//                 if err != nil {
//                         return nil, err
//                 }

//                 yearsIncomeData = append(yearsIncomeData, data)
//         }

//         if err := rows.Err(); err != nil {
//                 return nil, err
//         }

//         return yearsIncomeData, nil
// }

// // InsertIncome は新規登録
// //
// // 引数:
// //   - UserId: ユーザーID
// //
// // 戻り値:
// //
// //        戻り値1: 取得したDBの構造体
// //        戻り値2: エラー内容(エラーがない場合はnil)
// //

// func (pf *SingInDataFetcher) InsertIncome(data []InsertIncomeData) error {

//         var err error
//         createdAt := time.Now()

//         // トランザクションを開始
//         tx, err := pf.db.Begin()
//         if err != nil {
//                 fmt.Println(err)
//                 return err
//         }
//         defer func() {
//                 if err != nil {
//                         // エラーが発生した場合、トランザクションをロールバック
//                         tx.Rollback()
//                 } else {
//                         // エラーが発生しなかった場合、トランザクションをコミット
//                         err = tx.Commit()
//                 }
//         }()

//         insertStatement := DB.InsertIncomeSyntax

//         for _, insertData := range data {
//                 data := InsertIncomeData{
//                         PaymentDate:     insertData.PaymentDate,
//                         Age:             insertData.Age,
//                         Industry:        insertData.Industry,
//                         TotalAmount:     insertData.TotalAmount,
//                         DeductionAmount: insertData.DeductionAmount,
//                         TakeHomeAmount:  insertData.TakeHomeAmount,
//                         Classification:  insertData.Classification,
//                         UserID:          insertData.UserID,
//                 }
//                 uuid := uuid.New().String()
//                 if _, err = tx.Exec(insertStatement,
//                         uuid,
//                         data.PaymentDate,
//                         data.Age,
//                         data.Industry,
//                         data.TotalAmount,
//                         data.DeductionAmount,
//                         data.TakeHomeAmount,
//                         createdAt,
//                         data.Classification,
//                         data.UserID); err != nil {
//                         tx.Rollback()
//                         fmt.Println(err)
//                 }
//         }

//         // トランザクションをコミット
//         err = tx.Commit()
//         if err != nil {
//                 fmt.Println(err)
//                 return err
//         }

//         defer pf.db.Close()

//         return nil
// }

// // UpdateIncome は更新
// //
// // 引数:
// //   - UserId: ユーザーID
// //
// // 戻り値:
// //
// //        戻り値1: 取得したDBの構造体
// //        戻り値2: エラー内容(エラーがない場合はnil)
// //

// func (pf *SingInDataFetcher) UpdateIncome(data []UpdateIncomeData) error {

//         var err error
//         createdAt := time.Now()

//         // トランザクションを開始
//         tx, err := pf.db.Begin()
//         if err != nil {
//                 fmt.Println(err)
//                 return err
//         }
//         defer func() {
//                 if err != nil {
//                         // エラーが発生した場合、トランザクションをロールバック
//                         tx.Rollback()
//                 } else {
//                         // エラーが発生しなかった場合、トランザクションをコミット
//                         err = tx.Commit()
//                 }
//         }()

//         updateStatement := DB.UpdateIncomeSyntax

//         for _, updateData := range data {
//                 data := UpdateIncomeData{
//                         IncomeForecastID: updateData.IncomeForecastID,
//                         PaymentDate:      updateData.PaymentDate,
//                         Age:              updateData.Age,
//                         Industry:         updateData.Industry,
//                         TotalAmount:      updateData.TotalAmount,
//                         DeductionAmount:  updateData.DeductionAmount,
//                         TakeHomeAmount:   updateData.TakeHomeAmount,
//                         UpdateUser:       updateData.UpdateUser,
//                         Classification:   updateData.Classification,
//                 }
//                 if _, err = tx.Exec(updateStatement,
//                         data.PaymentDate,
//                         data.Age,
//                         data.Industry,
//                         data.TotalAmount,
//                         data.DeductionAmount,
//                         data.TakeHomeAmount,
//                         createdAt,
//                         data.UpdateUser,
//                         data.Classification,
//                         data.IncomeForecastID); err != nil {
//                         tx.Rollback()
//                         fmt.Println(err)
//                 }
//         }

//         // トランザクションをコミット
//         err = tx.Commit()
//         if err != nil {
//                 fmt.Println(err)
//                 return err
//         }

//         defer pf.db.Close()

//         return nil
// }

// // DeleteIncome は削除
// //
// // 引数:
// //   - UserId: ユーザーID
// //
// // 戻り値:
// //
// //        戻り値1: 取得したDBの構造体
// //        戻り値2: エラー内容(エラーがない場合はnil)
// //

// func (pf *SingInDataFetcher) DeleteIncome(data []DeleteIncomeData) error {

//         var err error

//         // トランザクションを開始
//         tx, err := pf.db.Begin()
//         if err != nil {
//                 fmt.Println(err)
//                 return err
//         }
//         defer func() {
//                 if err != nil {
//                         // エラーが発生した場合、トランザクションをロールバック
//                         tx.Rollback()
//                 } else {
//                         // エラーが発生しなかった場合、トランザクションをコミット
//                         err = tx.Commit()
//                 }
//         }()

//         deleteStatement := DB.DeleteIncomeSyntax

//         for _, deleteData := range data {
//                 if _, err = tx.Exec(deleteStatement, deleteData.IncomeForecastID); err != nil {
//                         tx.Rollback()
//                         fmt.Println(err)
//                 }
//         }

//         // トランザクションをコミット
//         err = tx.Commit()
//         if err != nil {
//                 fmt.Println(err)
//                 return err
//         }

//         defer pf.db.Close()

//         return nil
// }
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
